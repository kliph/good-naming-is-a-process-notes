Link to the original article: http://arlobelshee.com/good-naming-is-a-process-not-a-single-step/

I had not read this series before, so I'm glad to have the opportunity to read it. I'm reminded of Zach Tellman's Elements of Clojure (https://leanpub.com/elementsofclojure) with regard to the idea of nonsense vs. sense names and the complicated process of naming in general. It seems to me that Tellman and Benshee would share a lot of common ground on the idea that we are writing code primarily to communicate with others and ourselves in the future.

While I don't disagree in principle with the conclusions of the articles, I do question the methodology of reasoning from aphorisms. If, for instance, making a method longer or more nested results in more bugs when people edit it, we should be able to design an experiment to measure a relationship between cyclomatic complexity and rate of bugs. Adam Tornhill's Your Code as a Crime Scene has some good tools for performing this sort of analysis: https://pragprog.com/book/atcrime/your-code-as-a-crime-scene.

There are a number of similar claims in this series to which I remain skeptical until we can prove
them with a modicum of evidence. For instance, it seems reasonable that bugs arise from an incomplete understanding. We should be able to demonstrate that in an experiment.

One problem that I see with this approach is that two reasonable authors can come up with completely different seemingly useful, insightful, sensible names. The process of refining the names in a piece of code never reaches a perfect ideal. I appreciate Benshee's recommendation to check-in incremental improvements as they happen, but this must be tempered by code review in order to ensure that improvements reflect a shared understanding among all of the programmers involved rather than a single author. Another approach that I've found useful is to build a glossary of domain terms so that, for a given element of the domain, there is one and only one term of art for that thing. I typically do this in a detailed README.

I agree in large part with the post about refactoring. I’m reminded of one of my professors teaching me about “lumpers” and “splitters” in science. Lumpers tend to try to group similar ideas into a cohesive gestalt in order to gain some explanatory power through the agglomerated whole. Splitters tend to try to gain explanatory power by breaking things down into their atomic parts and understanding the similarities among things that share similar parts. I remain unconvinced that the process of encapsulation that Benshee is advocating for is as clear cut as Benshee makes it sound. I fear that introducing more named parts may necessarily make your code less comprehensible to humans based on the sheer number of things to keep in working memory. I have not seen good evidence to support certain kinds of abstraction and encapsulation over others. So I suspect, we're in the wild west here and Benshee's recommendations are consistent with the practices I try to implement in my day-to-day software development.

The rules of thumb Benshee recommends for naming are, in my opinion, specific to Benshee's domain. I'm comfortable using "Impl" to refer to the implementation of some abstract protocol or process controlled by a larger exception handling block, but those meanings may vary depending on the language in use and the other developers with whom my code is communicating information.

In the next article about getting to honest names, I find the example a bit contrived. However, I agree with Benshee that the it can be useful to change a name in such a way that it will remind you of your current insights in the future.

Again, in this next article about getting to complete and honest names, Benshee seems to be talking about lumpers and splitters as I characterize them above. I'm in favor of long, descriptive names. I see no reason to set artificial limits on the length of a name.

The next article about getting to doing the right thing seems to be more about encapsulating behavior such that names are accurate rather than ensuring that code is optimal or efficient. My confusion at the definition of the right thing further illustrates that multiple authors can have multiple goals in refactoring. It would be useful to have an objective empirical standard to work towards. Until then, Benshee's recommendations seem more or less reasonable.

With regard to the next article, I agree with Benshee that this can be the most challenging part. Coming up with a set of semantic rules to convey the intent of methods is a tricky challenge. I've found that these semantic categories tend to emerge over the course of working on a project, and the challenge becomes recognizing them and enforcing them. Distinguishing between methods that "get" as opposed to "fetching" data comes to mind.

After finishing the blog series, I'm left with a desire to read Domain-Driven Design by Eric Evans: https://www.oreilly.com/library/view/domain-driven-design-tackling/0321125215/. My general take is that, while I largely agree with and use the methodology Benshee describes, I suspect that there could be some surprising new directions if these methods were subjected to empirical scrutiny.
